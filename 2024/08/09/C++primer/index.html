<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ Primer学习记录 | shhyの小屋</title><meta name="author" content="shhy"><meta name="copyright" content="shhy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ Primer学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer学习记录">
<meta property="og:url" content="http://example.com/2024/08/09/C++primer/index.html">
<meta property="og:site_name" content="shhyの小屋">
<meta property="og:description" content="C++ Primer学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/top_2.png">
<meta property="article:published_time" content="2024-08-09T03:29:59.000Z">
<meta property="article:modified_time" content="2025-03-17T06:05:43.878Z">
<meta property="article:author" content="shhy">
<meta property="article:tag" content="语言学习">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/top_2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/08/09/C++primer/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: shhy","link":"链接: ","source":"来源: shhyの小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ Primer学习记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-17 14:05:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 22
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s11.ax1x.com/2024/01/23/pFeC0qH.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/top_2.png')"><nav id="nav"><span id="blog-info"><a href="/" title="shhyの小屋"><span class="site-name">shhyの小屋</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ Primer学习记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-09T03:29:59.000Z" title="发表于 2024-08-09 11:29:59">2024-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-17T06:05:43.878Z" title="更新于 2025-03-17 14:05:43">2025-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-Primer/">C++ Primer</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ Primer学习记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>第二章 变量类型</h1>
<h2 id="基本类型">基本类型</h2>
<h2 id="变量">变量</h2>
<h2 id="复合类型">复合类型</h2>
<h2 id="const限定符">const限定符</h2>
<h3 id="const的引用">const的引用</h3>
<h3 id="指针和const">指针和const</h3>
<p>接下来介绍两个比较重要的概念：<br>
1.顶层const，这是指该对象为常量，例如const int i，int *const p，其中i为一常量，不可改变，p为常量指针，不可改变；<br>
2.底层const，大部分适用于指针或引用等复合类型，例如const int *p，这个表示p为一int型指针，且其指向的内容不可变，不可通过指针p来修改*p的值，即指向常量的指针，而p可变，因此为底层const；而引用为特例，const int &amp;p为底层const，所有的用于声明引用的const都为底层const，不妨考虑一下，引用为目标对象的别名，其无对象实体，自然是不存在赋值这一说，而const只可加于其目标之上，故为底层const。</p>
<h3 id="顶层const">顶层const</h3>
<h3 id="constexpr和变量表达式">constexpr和变量表达式</h3>
<h1>第三章 string、数组、vector</h1>
<h1>第四章 表达式</h1>
<h2 id="变量强转">变量强转</h2>
<p>主要包括四种方式，其用法都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>a</mi><mi>s</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>&lt;</mo><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo>&gt;</mo><mo stretchy="false">(</mo><mi>e</mi><mi>x</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">cast\_name &lt;type&gt; (expression)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9251em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">nam</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord mathnormal">ress</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，具体描述如下：<br>
1.static_cast，表示静态转换，对于不包含底层const的目标，都可以使用static_cast，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">double p = static_cast &lt;double&gt; (i) / j; //把i强转为了double类型</span><br></pre></td></tr></table></figure>
<p>2.const_cast，主要作用是消除目标的底层const，例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *cp; <span class="comment">//底层const，*cp的内容不可变</span></span><br><span class="line"><span class="type">char</span> *p = <span class="keyword">const_cast</span> &lt;<span class="type">char</span>*&gt; (cp); <span class="comment">//正确，可通过p修改*p的内容</span></span><br><span class="line"><span class="type">char</span> *p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (cp); <span class="comment">//错误，static不可去底层const</span></span><br><span class="line"><span class="keyword">static_cast</span> &lt;string&gt; (cp); <span class="comment">//正确,将字面值常量转化为string对象，生成新对象</span></span><br><span class="line"><span class="keyword">const_cast</span> &lt;string&gt; (cp); <span class="comment">//错误,const_cast仅可去底层const，不可修改类型</span></span><br></pre></td></tr></table></figure>
<p>3.reinterpret_cast，其作用为对运算对象的位模式提供更低层次上的解释，一般不常用，感觉容易出错，例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip;</span><br><span class="line"><span class="type">char</span> *cp = <span class="keyword">reinterpret_cast</span> &lt;<span class="type">char</span>*&gt; (ip); <span class="comment">//将ip转化为了char*指针</span></span><br></pre></td></tr></table></figure>
<p>4.旧式的强转，即(type) expr 或者 type (expr)，本质上也是分为上述的情况，只是用起来约束少，但更无序，可能容易出bug。</p>
<h1>第五章 语句</h1>
<h1>第六章 函数</h1>
<p>数组指针：</p>
<p>该指针的指向对象是一个数组，其应该指定了固定大小的数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>]; <span class="comment">//arrT为10个含整数的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//返回含10个整数的数组指针</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>]; <span class="comment">//含10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>]; <span class="comment">//p1是含10个指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>] = &amp;arr; <span class="comment">//p2指向了一个含10个int的数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>返回指针数组的函数声明:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mo stretchy="false">(</mo><mo>∗</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mo stretchy="false">(</mo><mi>p</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>d</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">type (*func(params))[dimension]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord">∗</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">am</span><span class="mord mathnormal">s</span><span class="mclose">))</span><span class="mopen">[</span><span class="mord mathnormal">d</span><span class="mord mathnormal">im</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose">]</span></span></span></span>；</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func(int i) 标准的函数声明，只是没有函数返回类型</span></span><br><span class="line"><span class="comment">(*func(int i)) 意味着对函数的返回值进行了解引用的操作</span></span><br><span class="line"><span class="comment">(*func(int i))[10] 表示解引用结果是大小为10的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>c++11提供了更方便的方式，即通过auto使用尾置返回类型；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>; <span class="comment">// 返回的是一个指针，且该指针指向长度为10的整数数组</span></span><br></pre></td></tr></table></figure>
<p>使用decltype能更好的返回数组指针，如下所示；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">func</span> (<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> (i &amp; <span class="number">1</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数返回结果为odd类型的指针，odd为大小为5的整数数组</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="题6-36">题6.36</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用typedef别名</span></span><br><span class="line"><span class="keyword">typedef</span> string str[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// using str = string[10];</span></span><br><span class="line"><span class="function">str* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用原始类型;</span></span><br><span class="line"><span class="built_in">string</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用auto尾置</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">string</span> <span class="params">(*)</span>[10]</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用decltype</span></span><br><span class="line">string x = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(x) * <span class="built_in">func</span>(<span class="type">int</span> i);</span><br></pre></td></tr></table></figure>
<h4 id="题6-37">题6.37</h4>
<p>个人感觉auto尾置最好，因为尾置返回声明更清晰可见。</p>
<h4 id="题6-38">题6.38</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (&amp;<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">同理分析</span></span><br><span class="line"><span class="comment">&amp;func(int i) 返回值为一个引用</span></span><br><span class="line"><span class="comment">(&amp;func(int i))[10] 返回值为大小10的数组的引用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="函数重载">函数重载</h2>
<p>1函数重载需要具有不同的参数数量or类型；</p>
<p>2.main不可重载；</p>
<p>3.仅返回类型不同的函数不可重载；</p>
<p>4.顶层const不影响传入的对象，即非顶层const的对象，仍旧能使用顶层const的函数，因此，无法对添加了顶层const的进行区分；而底层const能进行区分为常量对象or非常量对象，因此可做重载；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载失败的顶层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const int 为指向对象为int常量，因此为顶层const</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> )</span></span>;</span><br><span class="line"><span class="comment">//该指针为常量，不可改变指针所指的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> * <span class="type">const</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载的底层const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用无对象，仅其引用对象不可改，为底层const</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 指针可改变，而所指对象不可改变，为常量指针，底层const</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="题6-39">题6.39</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">const</span> <span class="type">int</span>,<span class="type">const</span> <span class="type">int</span>)</span></span>; <span class="comment">// 不合法，顶层const为同一函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">()</span></span>; <span class="comment">//不合法，参数一致</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">reset</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> *<span class="title">reset</span><span class="params">(<span class="type">double</span> *)</span></span>; <span class="comment">//合法，返回double类型的指针</span></span><br></pre></td></tr></table></figure>
<h3 id="重载与作用">重载与作用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">double</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(string )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> read = <span class="literal">false</span>; <span class="comment">// 会隐藏外部read函数</span></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">read</span>(); <span class="comment">// 不合法，read函数被隐藏</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 不建议，会隐藏外部的同名函数</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.14</span>); <span class="comment">// 调用func(int);</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;shhy&quot;</span>); <span class="comment">//出错，func(string)被隐藏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊用途语言特性">特殊用途语言特性</h2>
<h3 id="默认实参">默认实参</h3>
<p>1.函数的参数可以赋予一定的默认值，函数在传入参数不满时，拥有默认参数的值会进行填充，但是，要注意的是，可省略传入参数的一定是函数尾部的实参；</p>
<p>2.默认实参不可修改，但可以进行添加默认实参；</p>
<p>3.具有默认实参的参数一定是尾部几个参数;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(string s = <span class="string">&quot;shhy&quot;</span>, <span class="type">int</span> x = <span class="number">10</span>,<span class="type">int</span> y = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="string">&quot;?&quot;</span>); <span class="comment">// func(&quot;?&quot;,10,10);</span></span><br><span class="line"><span class="built_in">func</span>(,<span class="number">11</span>,,) <span class="comment">// 不合法，省略的仅能是尾部的实参</span></span><br><span class="line">    </span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>; <span class="comment">// 无默认宽高</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">// 错误，重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">10</span>,sz = <span class="number">10</span>,<span class="type">char</span>)</span></span>; <span class="comment">// 添加默认实参</span></span><br></pre></td></tr></table></figure>
<p>4.如果想要修改默认实参值，可以使用默认实参赋值为变量，修改变量来完成这一过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下边三个变量于外部进行了声明</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(),sz = wd,<span class="type">char</span> = def)</span></span>;</span><br><span class="line">string window = <span class="built_in">screen</span>(); <span class="comment">// 调用了screen(ht(),80,&#x27; &#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sz wd = <span class="number">100</span>;</span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    string window = <span class="built_in">screen</span>(); <span class="comment">//调用screen(ht(),80,&#x27;*&#x27;),局部变量不改变，全局改变 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题6-40">题6.40</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b = <span class="number">0</span>,<span class="type">int</span> c = <span class="number">0</span>)</span></span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">init</span><span class="params">(<span class="type">int</span> ht = <span class="number">24</span>,<span class="type">int</span> wd,<span class="type">char</span> bkgrd)</span></span>; <span class="comment">// 错误，非尾部默认实参</span></span><br></pre></td></tr></table></figure>
<h4 id="题6-41">题6.41</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">init</span><span class="params">(<span class="type">int</span> ht, <span class="type">int</span> wd = <span class="number">80</span>, <span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">// 合法声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">init</span>(); <span class="comment">// 错误，ht无参数</span></span><br><span class="line"><span class="built_in">init</span>(<span class="number">24</span>,<span class="number">10</span>); <span class="comment">// init(24,10,&#x27; &#x27;);</span></span><br><span class="line"><span class="built_in">init</span>(<span class="number">14</span>,<span class="string">&#x27;*&#x27;</span>); <span class="comment">// init(14,(int)&#x27;*&#x27;,&#x27; &#x27;),发生强转</span></span><br></pre></td></tr></table></figure>
<h4 id="题6-42">题6.42</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">make_plural</span><span class="params">(<span class="type">size_t</span> ctr,<span class="type">const</span> string &amp;word,<span class="type">const</span> string &amp;ending = <span class="string">&quot;s&quot;</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ctr &gt; <span class="number">1</span> ? word + ending : word;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数 const string &amp;是指常量引用，而const string也是常量，但会创建副本</span></span><br><span class="line"><span class="built_in">make_plural</span>(<span class="number">2</span>,<span class="string">&quot;success&quot;</span>,<span class="string">&quot;es&quot;</span>);</span><br><span class="line"><span class="built_in">make_plural</span>(<span class="number">2</span>,<span class="string">&quot;failure&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="内联函数和constexpr函数">内联函数和constexpr函数</h2>
<p>1.内联函数inline，将代码替换成函数内容，做展开，消除调用开销；</p>
<p>2.constexpr函数能用作偶常量表达式，前提是 其return以及形参类型都应该为<strong>字面值类型</strong>，且函数体仅有一条return；</p>
<p>3.允许返回值不是 一个常量，即有输入，根据输入决定是否能用于常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">10</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">size_t</span> x)</span> </span>&#123;<span class="keyword">return</span> x * <span class="built_in">sz</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[<span class="built_in">func</span>(<span class="number">2</span>)]; <span class="comment">//正确，2是常量，func(2)仍为常量</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> t[<span class="built_in">func</span>(i)]; <span class="comment">//错误，func(i)非常量表达式</span></span><br></pre></td></tr></table></figure>
<h4 id="题6-43">题6.43</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">inline</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span></span></span></span>函数放在头文件。</p>
<h4 id="题6-44">题6.44</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;x,<span class="type">const</span> string &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">size</span>() &lt; y.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题6-45">题6.45</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>k</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>p</mi><mi>l</mi><mi>u</mi><mi>r</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">make\_plural</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">mak</span><span class="mord mathnormal">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">pl</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>可以改。</p>
<h4 id="题6-46">题6.46</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;x,<span class="type">const</span> string &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">size</span>() &lt; y.<span class="built_in">size</span>() ? <span class="literal">true</span> : fal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题6-50">题6.50</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>,<span class="type">double</span> = <span class="number">3.14</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.5</span>,<span class="number">42</span>); <span class="comment">//有二义性</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">42</span>,<span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">2.5</span>,<span class="number">3.14</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="函数指针">函数指针</h3>
<p>1.函数指针指向的是函数，其指定了函数的输入以及返回值；</p>
<p>2.函数指针使用时必须将指针与函数的类型精确匹配，对于重载函数也是如此，并非去做最优选择；</p>
<p>3.函数指针可作为形参使用，其输入类型可定义为函数，也可以定义为函数指针，因为函数作为参数传入其他位置，也会自动转为函数指针；</p>
<p>4.为了简化使用函数指针，可以使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi><mi>d</mi><mi>e</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">typedef</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">using</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">s</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>关键字定义函数指针为等价类型；</p>
<p>5.返回指向函数的指针时，不可以直接使用函数作为返回值，而必须使用函数指针，此时的函数不会自动变为函数指针；</p>
<p>6.可以使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">auto</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">o</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>c</mi><mi>l</mi><mi>t</mi><mi>y</mi><mi>p</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">decltype</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">lt</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span></span></span></span>关键字来返回函数类型，但要加上解引用的*从而返回函数指针，而非函数本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpStringlength</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func - func3都是函数类型，而非函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(sumLength)</span> func1</span>;</span><br><span class="line"><span class="keyword">using</span> func2 = <span class="built_in">bool</span> (<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="keyword">using</span> func3 = <span class="keyword">decltype</span>(sumLength);</span><br><span class="line"></span><br><span class="line"><span class="comment">// funcP - funcP3都是函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*funcP)</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(sumLength)</span> *funcP1</span>;</span><br><span class="line"><span class="keyword">using</span> funcP2 = <span class="built_in">bool</span> (*)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line"><span class="keyword">using</span> funcP3 = <span class="keyword">decltype</span>(sumLength) *;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数与函数指针的重命名</span></span><br><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*) (<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数与函数指针的测试</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 返回函数指针，正确</span></span><br><span class="line"><span class="comment">//F f2(int); // 返回函数，报错</span></span><br><span class="line"><span class="function">F *<span class="title">f3</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">// 返回函数指针，正确</span></span><br><span class="line"><span class="keyword">decltype</span>(cmpStringlength)* <span class="built_in">f4</span>(<span class="type">int</span>); <span class="comment">//返回cmp的函数类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将函数作为参数输入</span></span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">getLongestString</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;, func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数指针声明</span></span><br><span class="line">    <span class="built_in">bool</span> (*pf) (<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);</span><br><span class="line">    <span class="comment">//pf = sumLength; 参数类型不同，不可使用</span></span><br><span class="line">    pf = <span class="number">0</span>;</span><br><span class="line">    pf = cmpStringlength; <span class="comment">// 函数指针直接赋值即可，使用引用也一样</span></span><br><span class="line">    <span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;good&quot;</span>,<span class="string">&quot;bye&quot;</span>); <span class="comment">//调用cmpStringlength</span></span><br><span class="line">    <span class="type">bool</span> b2 = (*)(<span class="string">&quot;good&quot;</span>,<span class="string">&quot;bye&quot;</span>); <span class="comment">//调用cmpStringlength另一种方法</span></span><br><span class="line">    <span class="type">bool</span> b3 = <span class="built_in">cmpStringlength</span>(<span class="string">&quot;good&quot;</span>,<span class="string">&quot;bye&quot;</span>); <span class="comment">//原始调用方法</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getLongestString</span>(<span class="string">&quot;good&quot;</span>, <span class="string">&quot;bye&quot;</span>, pf) &lt;&lt; endl; <span class="comment">// 调用函数，也可以使用 *pf,会自动变为函数指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmpStringlength</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">length</span>() &lt; s2.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">getLongestString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, func f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">f</span>(s1, s2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="题6-54-6-56">题6.54-6.56</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数以及函数指针声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*func)</span> <span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector &lt;func&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(add);</span><br><span class="line">    v.<span class="built_in">push_back</span>(sub);</span><br><span class="line">    v.<span class="built_in">push_back</span>(mul);</span><br><span class="line">    v.<span class="built_in">push_back</span>(division);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">// 调用函数指针只需要当作函数即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;v[i](a,b)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">division</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>第七章 类</h1>
<p>？？？</p>
<h2 id="抽象类定义">抽象类定义</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sales_data</span> &#123;</span><br><span class="line">    <span class="comment">// 类内及类外的构造函数声明</span></span><br><span class="line">    <span class="built_in">sales_data</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">sales_data</span>(<span class="type">const</span> std::string &amp;b, <span class="type">unsigned</span> u, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(b), <span class="built_in">units_sold</span>(u), <span class="built_in">revenue</span>(p*u) &#123;&#125;</span><br><span class="line">    <span class="built_in">sales_data</span>(istream &amp;is);</span><br><span class="line">    <span class="comment">// 类内函数，两个使用了const成员函数</span></span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> units_sold? revenue/units_sold : <span class="number">0.0</span>;&#125;;</span><br><span class="line">    <span class="comment">// 类内属性</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类内函数的定义</span></span><br><span class="line"><span class="function">sales_data&amp; <span class="title">sales_data::combine</span><span class="params">(<span class="type">const</span> sales_data&amp; rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类外函数的声明</span></span><br><span class="line"><span class="function">sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> sales_data&amp;,<span class="type">const</span> sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> sales_data &amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,sales_data &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 类外函数的定义</span></span><br><span class="line"><span class="function">sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> sales_data&amp; lhs, <span class="type">const</span> sales_data&amp; rhs)</span> </span>&#123;</span><br><span class="line">    sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> sales_data&amp; sd)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; sd.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sd.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sd.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sd.<span class="built_in">avg_price</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp; is, sales_data&amp; sd)</span> </span>&#123;</span><br><span class="line">    is &gt;&gt; sd.bookNo &gt;&gt; sd.units_sold &gt;&gt; sd.revenue;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类外的构造函数，因为需要使用read函数，要放在其声明之下</span></span><br><span class="line">sales_data::<span class="built_in">sales_data</span>(istream &amp;is) &#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.定义在类内部的函数是有隐式inline的，以便运行更快；</p>
<p>2.详解一下<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>d</mi><mo>:</mo><mo>:</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>i</mi><mi>s</mi><mi>b</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo stretchy="false">{</mo><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mtext> </mtext><mi>b</mi><mi>o</mi><mi>o</mi><mi>k</mi><mi>N</mi><mi>o</mi><mo separator="true">;</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">std::string\space isbn() \{return\space bookNo;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">bn</span><span class="mopen">(</span><span class="mclose">)</span><span class="mopen">{</span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mspace"> </span><span class="mord mathnormal">b</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mclose">}</span></span></span></span>这句函数，由前缀可以得知，该函数的返回类型为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>d</mi><mo>:</mo><mo>:</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">std::string</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>，其调用时应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>s</mi><mi>b</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">data.isbn()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord">.</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">bn</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>。内存中有一个隐式参数，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>，该参数指明了当前使用的显示参数的地址，因此，实际上其调用结果，在外部函数看来，应该是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>:</mo><mo>:</mo><mi>i</mi><mi>s</mi><mi>b</mi><mi>n</mi><mo stretchy="false">(</mo><mi mathvariant="normal">&amp;</mi><mi>N</mi><mi>o</mi><mi>w</mi><mi mathvariant="normal">_</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">data::isbn(\&amp;Now\_value)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">bn</span><span class="mopen">(</span><span class="mord">&amp;</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span>（伪代码），其中便可得到当前的参数地址，从而返回当前地址内的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>o</mi><mi>o</mi><mi>k</mi><mi>N</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">bookNo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span></span></span></span>参数的值。值得注意的是，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>为一种顶层修饰的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>指针，其所指的地址并不能通过代码进行显式的修改；</p>
<p>3.引入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>用于成员函数时，并不修饰引入的形参，而是加入函数后，用于修饰隐式的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>变量，这种方法叫做<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数，上述函数便可书写为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>d</mi><mo>:</mo><mo>:</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>:</mo><mo>:</mo><mi>i</mi><mi>s</mi><mi>b</mi><mi>n</mi><mo stretchy="false">(</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mtext> </mtext><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>∗</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo stretchy="false">)</mo><mtext> </mtext><mo stretchy="false">{</mo><mi>r</mi><mi>e</mi><mi>t</mi><mi>u</mi><mi>r</mi><mi>n</mi><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi><mo>−</mo><mo>&gt;</mo><mi>i</mi><mi>s</mi><mi>b</mi><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">std::string\space data::isbn(const\space data*const\space this)\space \{return this-&gt; isbn\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">bn</span><span class="mopen">(</span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace"> </span><span class="mopen">{</span><span class="mord mathnormal">re</span><span class="mord mathnormal">t</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">bn</span><span class="mclose">}</span></span></span></span>(伪代码)；</p>
<p>4.计算机编译过程是先编译成员内的声明，然后再编译函数体，因此无论成员位于声明的上下方，都可以编译函数体，无需在意成员出现的次序；</p>
<p>5.可以在类外定义成员函数，其与声明相匹配即可，包括<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数；</p>
<p>6.如果没有构造函数，会执行默认构造函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>b</mi><mi>j</mi><mo>=</mo><mi>d</mi><mi>e</mi><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">obj=default</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.05724em;">bj</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span></span></span></span>，但是最好设置空的默认构造函数，因为有些编译器可能不支持<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">defalut</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span></span></span></span>的构造函数；</p>
<p>7.C++11中，要显示的使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">default</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span></span></span></span>构造函数，要使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>a</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo>=</mo><mi>d</mi><mi>e</mi><mi>f</mi><mi>a</mi><mi>u</mi><mi>l</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sales\_data=default</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">es</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">a</span><span class="mord mathnormal">u</span><span class="mord mathnormal">lt</span></span></span></span>语句；</p>
<p>8.可以使用构造函数初值列表来写构造函数，其使用方法是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>a</mi><mi>l</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mo stretchy="false">(</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>s</mi><mo separator="true">,</mo><mi>u</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>e</mi><mi>d</mi><mtext> </mtext><mi>x</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>d</mi><mi>o</mi><mi>u</mi><mi>b</mi><mi>l</mi><mi>e</mi><mtext> </mtext><mi>y</mi><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo><mo>:</mo><mi>b</mi><mi>o</mi><mi>o</mi><mi>k</mi><mi>N</mi><mi>o</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>o</mi><mi>l</mi><mi>d</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>r</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>u</mi><mi>e</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mrow></mrow></mrow><annotation encoding="application/x-tex">sales\_data(string\space s,unsigned\space x = 0,double\space y = 0) : bookNo(s),utils\_sold(x),revenue(y){}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">es</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal">o</span><span class="mopen">(</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal">so</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">re</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord"></span></span></span></span>;</p>
<p>9.构造函数也可以在类外定义，只需要在类内声明后，在类外与声明书写相匹配的函数体即可。</p>
<h3 id="题7-10">题7.10</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mo stretchy="false">(</mo><mi>c</mi><mi>i</mi><mi>n</mi><mo separator="true">,</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>i</mi><mi>f</mi><mo stretchy="false">(</mo><mi>c</mi><mi>i</mi><mi>n</mi><mo>&gt;</mo><mo>&gt;</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mn>1</mn><mo>&gt;</mo><mo>&gt;</mo><mi>d</mi><mi>a</mi><mi>t</mi><mi>a</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">if(read(read(cin,data1),data2))\iff if(cin &gt;&gt;data1&gt;&gt;data2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">re</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">in</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord">2</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⟺</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mord mathnormal">in</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>，检验是否输入两个数据</p>
<h3 id="题7-12">题7.12</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sales_data</span>(istream &amp;is) &#123;</span><br><span class="line">    is &gt;&gt; bookNo &gt;&gt; units_sold &gt;&gt; revenue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的封装以及访问控制">类的封装以及访问控制</h2>
<p>1.访问控制本质上就是了解Class与struct的区别，struct仅能让所有的成员变成public，而class在第一个访问控制符之前所有的属性都是private的；</p>
<p>2.如果想类外的一部分函数直接访问类内的属性，可以使用友元的方式，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">friend</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span></span></span></span>关键字，在函数内部声明友元函数即可，友元函数也不会受访问控制符的影响，因此放在哪个位置都可以；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sales_data</span> &#123;</span><br><span class="line">    <span class="comment">// 友元函数，可以访问sales_data内部的private属性</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> sales_data&amp;,<span class="type">const</span> sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;,<span class="type">const</span> sales_data &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;,sales_data &amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sales_data</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">sales_data</span>(<span class="type">const</span> std::string &amp;b, <span class="type">unsigned</span> u, <span class="type">double</span> p) : <span class="built_in">bookNo</span>(b), <span class="built_in">units_sold</span>(u), <span class="built_in">revenue</span>(p*u) &#123;&#125;</span><br><span class="line">    <span class="built_in">sales_data</span>(istream &amp;is) &#123;</span><br><span class="line">        is &gt;&gt; bookNo &gt;&gt; units_sold &gt;&gt; revenue;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> sales_data&amp;)</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> units_sold? revenue/units_sold : <span class="number">0.0</span>;&#125;;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="类的其它特性">类的其它特性</h2>
<p>1.类内可以含有用来定义类型的成员，这种成员必须先定义再使用；</p>
<p>2.类内可以含有其它类，但是内部的类必须要先做声明；</p>
<p>3.除了在类内直接定义完的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>n</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">inline</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">in</span><span class="mord mathnormal">e</span></span></span></span>函数，也可以在类内做内联声明或者在类外做内联声明；</p>
<p>4.类内的成员函数和外部函数其实并无区别，因此也可以用来做函数重载，只需要返回值或者参数 有差异即可；</p>
<p>5.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">mutable</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span></span></span></span>关键字是可变关键字，如果对于一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数，我们在无法修改类内值的情况下，仍想改动一个属性的值，可以使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>t</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">mutable</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ab</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span></span></span></span>关键字，将该属性定义为随时可变，不受<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数的约束；</p>
<p>6.类内成员的默认初始值可以使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">}</mo><mo separator="true">,</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">\{\},=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span></span></span></span>来进行初始赋值。</p>
<h3 id="返回-this的函数">返回*this的函数</h3>
<p>1.类内函数调用时由于多了一个隐式指针<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>，因此返回值可以为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>所指的对象，但是不可以返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>指针，因为其是隐式的，不可之后访问；</p>
<p>2.<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数由于对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>指针的对象做了常量的限制，所以其返回的对象为常量对象，不可作为非<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>对象使用；</p>
<p>3.为了应对不同的场景，有的时候可能需要根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>成员函数来做重载，两个成员函数加与不加<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>相当于传入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">*this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">∗</span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi><mtext> </mtext><mo>∗</mo><mi>t</mi><mi>h</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">const\space *this</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">s</span></span></span></span>，有底层<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">const</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span></span></span></span>的差异，因此是函数的重载；</p>
<h3 id="类类型">类类型</h3>
<h4 id="类的前向声明">类的前向声明</h4>
<p>1.类的声明与定义也可以分开，但是即便内部一模一样的两个类名字不同也是不同的；</p>
<p>2.类仅仅声明叫做前向声明，目前该类还是一个不完全类型。创建一个类需要知道该类需要多少空间，因此需要类定义，而非仅仅声明，所以前向声明应用场景非常有限，一般可以定义指向这种类型的指针or应用，也可以声明以不完全类型作为参数或者返回类型的函数，但是不可定义；</p>
<h3 id="友元再探">友元再探</h3>
<h4 id="类间的友元关系">类间的友元关系</h4>
<p>1.如果一个类需要另一个类使用自己的私有变量，则需要将其他类设置为友元类，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mtext> </mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">friend\space  class\space x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mspace"> </span><span class="mord mathnormal">x</span></span></span></span>；</p>
<p>2.一个类内也可以将其他类中的某一个函数设定为友元函数，使得其中的某个函数可以访问类内的私有变量，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mo>:</mo><mo>:</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">friend\space class::function()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mspace"> </span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">::</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">c</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>；</p>
<p>3.友元的声明并非函数的声明，其只是说该函数是某个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">class</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">ss</span></span></span></span>的友元，对于编译器来说，它只是默认友元函数是存在的，也并不知道其具体位置，可以将其声明放在友元声明上也可以放在下边，但是调用友元函数时，必须保证调用的函数之前有该友元函数的正确声明。</p>
<h2 id="类的作用域">类的作用域</h2>
<h3 id="名字查找与类的作用域">名字查找与类的作用域</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">shhy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/09/C++primer/">http://example.com/2024/08/09/C++primer/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">shhyの小屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">语言学习</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/top_2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/17/hexo%E9%85%8D%E7%BD%AE/" title="hexo配置"><img class="cover" src="/img/top_1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hexo配置</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/27/Comb-1/" title="组合数学第一章"><img class="cover" src="/img/top_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">组合数学第一章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s11.ax1x.com/2024/01/23/pFeC0qH.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">shhy</div><div class="author-info__description">普通人的记录</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/287029"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/287029" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1634363306@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">第二章 变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">复合类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">const限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">const的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8Cconst"><span class="toc-number">1.4.2.</span> <span class="toc-text">指针和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const"><span class="toc-number">1.4.3.</span> <span class="toc-text">顶层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constexpr%E5%92%8C%E5%8F%98%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">constexpr和变量表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">第三章 string、数组、vector</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">第四章 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%BC%BA%E8%BD%AC"><span class="toc-number">3.1.</span> <span class="toc-text">变量强转</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">第五章 语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">第六章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-36"><span class="toc-number">5.0.0.1.</span> <span class="toc-text">题6.36</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-37"><span class="toc-number">5.0.0.2.</span> <span class="toc-text">题6.37</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-38"><span class="toc-number">5.0.0.3.</span> <span class="toc-text">题6.38</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-39"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">题6.39</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">重载与作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">特殊用途语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="toc-number">5.2.1.</span> <span class="toc-text">默认实参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-40"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">题6.40</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-41"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">题6.41</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-42"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">题6.42</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">内联函数和constexpr函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-43"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">题6.43</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-44"><span class="toc-number">5.3.0.2.</span> <span class="toc-text">题6.44</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-45"><span class="toc-number">5.3.0.3.</span> <span class="toc-text">题6.45</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-46"><span class="toc-number">5.3.0.4.</span> <span class="toc-text">题6.46</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-50"><span class="toc-number">5.3.0.5.</span> <span class="toc-text">题6.50</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">5.3.1.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%986-54-6-56"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">题6.54-6.56</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">第七章 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">抽象类定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%987-10"><span class="toc-number">6.1.1.</span> <span class="toc-text">题7.10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%987-12"><span class="toc-number">6.1.2.</span> <span class="toc-text">题7.12</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">类的封装以及访问控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E5%AE%83%E7%89%B9%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">类的其它特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E-this%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">返回*this的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">类类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%89%8D%E5%90%91%E5%A3%B0%E6%98%8E"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">类的前向声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="toc-number">6.3.3.</span> <span class="toc-text">友元再探</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E9%97%B4%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">类间的友元关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.4.</span> <span class="toc-text">类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">6.4.1.</span> <span class="toc-text">名字查找与类的作用域</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/17/hexo%E9%85%8D%E7%BD%AE/" title="hexo配置"><img src="/img/top_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo配置"/></a><div class="content"><a class="title" href="/2025/03/17/hexo%E9%85%8D%E7%BD%AE/" title="hexo配置">hexo配置</a><time datetime="2025-03-17T05:58:00.000Z" title="发表于 2025-03-17 13:58:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/09/C++primer/" title="C++ Primer学习记录"><img src="/img/top_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++ Primer学习记录"/></a><div class="content"><a class="title" href="/2024/08/09/C++primer/" title="C++ Primer学习记录">C++ Primer学习记录</a><time datetime="2024-08-09T03:29:59.000Z" title="发表于 2024-08-09 11:29:59">2024-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/27/Comb-1/" title="组合数学第一章"><img src="/img/top_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="组合数学第一章"/></a><div class="content"><a class="title" href="/2024/01/27/Comb-1/" title="组合数学第一章">组合数学第一章</a><time datetime="2024-01-27T11:36:59.000Z" title="发表于 2024-01-27 19:36:59">2024-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/25/Combinatorics/" title="组合数学学习笔记"><img src="/img/top_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="组合数学学习笔记"/></a><div class="content"><a class="title" href="/2024/01/25/Combinatorics/" title="组合数学学习笔记">组合数学学习笔记</a><time datetime="2024-01-25T14:11:47.000Z" title="发表于 2024-01-25 22:11:47">2024-01-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/top_2.png')"><div id="footer-wrap"><div class="copyright">&copy;2024/01/23 - 2025 By shhy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>